<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TensorNetworkTensors.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TensorNetworkTensors.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Factorizations-1">Factorizations</a></li><li class="toplevel"><a class="toctext" href="#KrylovKit-1">KrylovKit</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TensorNetworkTensors.jl-1" href="#TensorNetworkTensors.jl-1">TensorNetworkTensors.jl</a></h1><p>Tensors for Tensor Network Methods. <code>TensorNetworkTensors.jl</code> overloads methods from <code>TensorOperations</code> and <code>KrylovKit</code> to work with Tensors that might be symmetric under some abelina symmetry.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><h3><a class="nav-anchor" id="Tensors-1" href="#Tensors-1">Tensors</a></h3><p>You can define tensors without symmetry using the <code>DTensor</code> type as</p><pre><code class="language-julia">julia&gt; a = DTensor{Complex{Float64}}((2,2));</code></pre><p>which will return a <code>2x2</code>-tensor with elements of type <code>Complex{Float64}</code>. <code>DTensor</code> is just a thin wrapper around <code>Array</code>.</p><p>A tensor with a symmetry can be defined by specifying the:</p><ol><li>symmetry</li><li>possible charge</li><li>sizes of the degeneracy spaces of those charge</li><li>action of the group acts on an index</li></ol><p>The currently implemented <em>Discrete Abelian Symmetries</em> are <code>U1</code> and <code>ZN</code> symmetries. To define a <code>U1</code> symmetric rank-3 tensor which, in the particle conservation picture, has two incoming, one outgoing leg and supports carrying between 3 and -3 particles per leg where each charge has a degeneracy-size of 2, we write:</p><pre><code class="language-julia">julia&gt; sym = U1()
julia&gt; chs = (U1Charges(-3:3), U1Charges(-3:3), U1Charges(-3:3))
julia&gt; dims = ([2 for ch in U1Charges(-3:3)],
                [2 for ch in U1Charges(-3:3)],
                [2 for ch in U1Charges(-3:3)])
julia&gt; io = InOut(1,1,-1)
julia&gt; a = DASTensor{Float64,3}(sym, chs, dims, io)</code></pre><p>where <code>a</code> is a <em>Discrete Abelian Symmetric</em> rank-3 tensor with degeneracy tensors of type <code>Float64</code>. It&#39;s first two indices can be read as <em>incoming</em> while the last is outgoing. All indices support charges in <code>U1Charges(-3:3)</code> which can be looked at using</p><pre><code class="language-julia">julia&gt; foreach(println, U1Charges(-3:3))
U1Charge(-3)
U1Charge(-2)
U1Charge(-1)
U1Charge(0)
U1Charge(1)
U1Charge(2)
U1Charge(3)</code></pre><p>The same for a Z2-symmetric tensor looks like</p><pre><code class="language-julia">julia&gt; sym = ZN{2}()
julia&gt; chs = (ZNCharges{2}(), ZNCharges{2}(), ZNCharges{2}())
julia&gt; dims = ([2 for ch in ZNCharges{2}()],
               [2 for ch in ZNCharges{2}()],
               [2 for ch in ZNCharges{2}()])
julia&gt; io = InOut(1,1,-1)
julia&gt; a = DASTensor{Float64,3}(sym, chs, dims, io)</code></pre><p>Above we just defined tensors but they are either filled with garbage (<code>DTensor</code>) or empty (<code>DASTensor</code>). To initialize a tensor, use <code>initwithzero!</code> or <code>initwithrand!</code>, e.g.</p><pre><code class="language-julia">julia&gt; a = DTensor{Complex{Float64}}((2,2))
DTensor{Complex{Float64},2}Complex{Float64}[6.93789e-310+6.93789e-310im 6.93789e-310+6.93786e-310im; 6.93789e-310+6.93786e-310im 6.93786e-310+6.93789e-310im]
julia&gt; initwithzero!(a)
DTensor{Complex{Float64},2}Complex{Float64}[0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]</code></pre><p>For tensors with symmetry - <code>DASTensor</code> - the same works but the underlying structure is different:</p><pre><code class="language-julia">julia&gt; sym = ZN{2}()
julia&gt; chs = (ZNCharges{2}(), ZNCharges{2}(), ZNCharges{2}())
julia&gt; dims = ([2 for ch in ZNCharges{2}()],
               [2 for ch in ZNCharges{2}()],
               [2 for ch in ZNCharges{2}()])
julia&gt; io = InOut(1,1,-1)
julia&gt; a = DASTensor{Float64,3}(sym, chs, dims, io);
julia&gt; initwithzero!(a)
julia&gt; tensor(a)</code></pre><p>To look into a <code>DASTensor</code>, you can use <code>tensor</code> to see the underlying dictionary which maps <code>DASSectors</code>, discrete abelian symmetry sectors, to degeneracy tensors.</p><pre><code class="language-julia">Dict{DASSector{3,ZNCharge{2}},Array{Float64,3}} with 4 entries:
  DASSector(Z2Charge(0), Z2Charge(0), Z2Charge(0)) =&gt; [0.0 0.0; 0.0 0.0]…
  DASSector(Z2Charge(0), Z2Charge(1), Z2Charge(1)) =&gt; [0.0 0.0; 0.0 0.0]…
  DASSector(Z2Charge(1), Z2Charge(0), Z2Charge(1)) =&gt; [0.0 0.0; 0.0 0.0]…
  DASSector(Z2Charge(1), Z2Charge(1), Z2Charge(0)) =&gt; [0.0 0.0; 0.0 0.0]…</code></pre><p>You can also directly access a degeneracy tensor like this:</p><pre><code class="language-julia">julia&gt; a[DASSector(Z2Charge(0), Z2Charge(0), Z2Charge(0))]
2×2×2 Array{Float64,3}:
[:, :, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2] =
 0.0  0.0
 0.0  0.0</code></pre><p>Specific functions for <code>DASTensors</code> include:</p><ul><li><code>charges</code>, <code>setcharges!</code></li><li><code>sizes</code>, <code>setsizes!</code></li><li><code>in_out</code>, <code>setin_out!</code></li><li><code>tensor</code>, <code>settensor!</code></li><li><code>isinvariant</code></li><li><code>charge</code></li></ul><p>to learn more, use <code>?</code> as in e.g.</p><pre><code class="language-julia">julia&gt;?charge
search: charge charges chargedim chargetype chargesize chargestype chargeindex ZNCharge Z2Charge U1Charge ZNCharges Z2Charges U1Charges DASCharge setcharges! DASCharges NDASCharge NDASCharges splitchargeit SplitChargeIt connectingcharge

  charge(a::DASSector)

  returns the charge which is calculated as the the sum of all charges it contains.

  ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

  charge(a::DASTensor)

  returns the charge which is calculated as the charge of its non-zero sectors which needs to be unique.</code></pre><h3><a class="nav-anchor" id="Reshaping-1" href="#Reshaping-1">Reshaping</a></h3><p>Reshaping can be done by either <em>fusing</em> or <em>splitting</em> legs. Since splitting with symmetries is highly nontrivial, it might only be done <em>after</em> a fusion which provides the necessary information of how to recombine indices and charges.</p><p>To fuse indices, we use the function <code>fuselegs</code>:</p><pre><code class="language-julia">help?&gt;fuselegs
  fuselegs(A, indexes)

  Fuse the indices in A as given by indexes where indexes is a tuple containing indices either alone or grouped in tuples - the latter will be fused. Returns a tuple of a tensor and the object necessary to undo the fusion.

  Examples
  ≡≡≡≡≡≡≡≡≡≡

  julia&gt; a = DTensor(collect(reshape(1:8,2,2,2))
  DTensor{Int64,3}[1 3; 2 4]
  [5 7; 6 8]
  julia&gt; fuselegs(a, ((1,2),3))
  (DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))

    ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

  fuselegs(A, indexes[, io])

  For DASTensors, the directions of the resulting legs might be specified. If io is ommitted, the default is InOut(1,1,1...).</code></pre><p>Fusion might also include permutation. Note that <code>fuselegs</code> returns two objects:</p><ol><li>A new tensor that corresponds to the input with the fusion applie</li><li>An object to <em>undo</em> that fusion.</li></ol><p>The latter is achieved using <code>splitlegs</code>:</p><pre><code class="language-julia">help?&gt; splitlegs
search: splitlegs splitlegs!

  splitlegs(A, indexes, rs...)

  Split the indices in A as given by indexes and rs. indexes is a tuple of integers and 3-tuple where each 3-tuple (i,j,k) specifies that index i in A is split according to rs[j], index k therein. Returns tensor with fused legs.

  Examples
  ≡≡≡≡≡≡≡≡≡≡

  julia&gt; a = DTensor(collect(reshape(1:8,2,2,2))
  DTensor{Int64,3}[1 3; 2 4]
  [5 7; 6 8]
  julia&gt; af, rs = fuselegs(a, ((1,2),3))
  (DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))
  julia&gt; splitlegs(af, ((1,1,1),(1,1,2),2), rs...)
  DTensor{Int64,3}[1 3; 2 4]
  [5 7; 6 8]</code></pre><p>The same is true for the case of <code>DASTensor</code>s, although <code>fuselegs</code> returns a more complicated object of the type <code>Reshaper</code>. If there is already a tensor of the correct shape and charges available, both <code>fuselegs</code> and <code>splitlegs</code> can be used as their <code>in-place</code> version <code>fuselegs!</code> and <code>splitlegs!</code> (see <code>help</code>).</p><p>Note that fusion is specified with <em>permutation</em> of the indices of a tensor and indices grouped in a tuple are fused, e.g. <code>((1,2),3)</code> means the first two indices of a rank-3 tensor are grouped whereas <code>(1,(4,3),2)</code> means that the third and fourth index of a rank-4 tensor are grouped and switched with the second index.</p><p>For splitting, indices are a list of integers and 3-tuples <code>(i,j,k)</code> where the latter specifies that index <code>i</code> in given tensor is split according to index <code>j</code> in the reshapeing-information and part <code>k</code> of that split is to be at the position of that tuple.</p><p>Let&#39;s look at an example:</p><pre><code class="language-julia">julia&gt; sym = U1()
julia&gt; chs = (U1Charges(-3:3), U1Charges(-3:3), U1Charges(-3:3))
julia&gt; dims = ([2 for ch in U1Charges(-3:3)],
                [2 for ch in U1Charges(-3:3)],
                [2 for ch in U1Charges(-3:3)])
julia&gt; io = InOut(1,1,1)
julia&gt; a = DASTensor{Float64,3}(sym, chs, dims, io)
julia&gt; initwithrand!(a)</code></pre><p>First we fuse indices 1 and 3 into <code>(3,1)</code> putting them in the first place and specifying the directions of the legs as both outgoing:</p><pre><code class="language-julia">julia&gt; af, rs = fuselegs(a, ((3,1),2),InOut(-1,-1))</code></pre><p>To undo that fusion, we need to split the first index of <code>af</code> according to the first reshaper in <code>rs</code> (there&#39;s a reshaper for each index in the fused tensor in order). A valid splitting would be:</p><pre><code class="language-julia">julia&gt; splitlegs(af,((1,1,1),(1,1,2),2),rs...)</code></pre><p>but that would correspond to a permutation <code>(3,1,2)</code> of <code>a</code>. Additionally, the unfused index was also changed by switching its <code>InOut</code>! We thus want to specify both the correct permutation and that index 2 needs to be changed accordingly, arriving at</p><pre><code class="language-julia">julia&gt; splitlegs(af, ((1,1,2),(2,2,1),(1,1,1)), rs...) ≈ a
true</code></pre><h2><a class="nav-anchor" id="Factorizations-1" href="#Factorizations-1">Factorizations</a></h2><p>So far the factorizations available are <code>tensorsvd</code> which returns the <code>SVD</code> of a tensor, see</p><pre><code class="language-julia">help?&gt; tensorsvd
search: tensorsvd tensorsvd! _tensorsvd TensorOperations

  tensorsvd(A::AbstractTensor, indexes; svdtrunc)

  works like tensorsvd except that A can have arbitrary rank.
  indexes specifies which indices the fuse for A to be a rank-2 tensor as in fuselegs.
  The tensor is then fused, tensorsvd applied and split again.

  ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

  tensorsvd(A::AbstractTensor{T,2}; svdtrunc)

  returns the svd of an AbstractTensor.
  svdtrunc is a function that has the singular values as input and returns a number specifying how many of them to keep.
  The default svdtrunc is svdtrunc_default and keeps all of them.

  Other options are: svdtruncdiscardzero svdtruncmaxχ svdtruncmaxcumerror svdtruncmaxerror</code></pre><p>and <code>tensorqr</code> which returns the <code>QR</code>-decomposition of a tensor, see</p><pre><code class="language-julia">help?&gt; tensorqr
search: tensorqr tensor tensorsvd tensoradd tensorsvd! tensortrace tensorcopy tensoradd! tensortrace! tensorcopy! tensorproduct tensorproduct! tensorcontract

  tensorqr(A::AbstractTensor)

  returns tensor Q,R such that A = QR and Q is an orthogonal/unitary matrix and R is an upper triangular matrix.

  ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

  tensorqr(A::AbstractTensor, inds)

  returns the tensorqr of A fused according to inds.</code></pre><h1><a class="nav-anchor" id="KrylovKit-1" href="#KrylovKit-1">KrylovKit</a></h1><p>All <code>AbstractTensor</code>s work with <code>KrylovKit</code>, a package that combines a number of Krylov-based algorithms including <em>exponentiate</em>.</p><p>To use KrylovKit, follow the instruction for installation at the <a href="https://github.com/Jutho/KrylovKit.jl">github repository</a> and do</p><pre><code class="language-julia">using KrylovKit</code></pre><p>As an example, consider <code>eigsolve</code> for a tensor with two independent symmetries:</p><pre><code class="language-julia">julia&gt; a = DASTensor{Complex{Float64},2}(
  NDAS(Z2(),U1()),
  (NDASCharges(Z2Charges(), U1Charges(-1:1)), NDASCharges(Z2Charges(), U1Charges(-1:1))),
  (fill(2,6), fill(2,6)),
  InOut(1,-1))
julia&gt; initwithrand!(a)
julia&gt; using TensorOperations
julia&gt; @tensor a[1,2] := a[1,2] + a&#39;[2,1];</code></pre><p>Since we are not working with a regular array, we need to provide an initial guess for an eigenvector, e.g.</p><pre><code class="language-julia">julia&gt; v0 = DASTensor{Complex{Float64},1}(
         NDAS(Z2(),U1()),
         (NDASCharges(Z2Charges(), U1Charges(-1:1)),),
         (fill(2,6),),
         InOut(1))
julia&gt; initwithrand!(v0)</code></pre><p>Then we can define a function for applying <code>a</code> to vectors like <code>v0</code>:</p><pre><code class="language-julia">julia&gt; f(v) = @tensor v2[1] :=  a[1,-1] * v[-1]</code></pre><p>Then we can use <code>eigsolve</code> with <code>f</code> and <code>v0</code> to get an eigenvector of <code>a</code> or the map that it describes:</p><pre><code class="language-julia">julia&gt; eigsolve(f,v0)
[...]</code></pre><p>which returns two eigenvalues, two eigenvectors and an object containing information about convergence.</p><p>Similarly we can apply <code>exp(0.1*a)</code> to <code>v0</code> with <code>exponentiate</code>:</p><pre><code class="language-julia">julia&gt; exponentiate(f,0.1,v0, ishermitian=true)</code></pre><ul><li><a href="#TensorNetworkTensors.AbstractTensor"><code>TensorNetworkTensors.AbstractTensor</code></a></li><li><a href="#TensorNetworkTensors.DAS"><code>TensorNetworkTensors.DAS</code></a></li><li><a href="#TensorNetworkTensors.DASCharge"><code>TensorNetworkTensors.DASCharge</code></a></li><li><a href="#TensorNetworkTensors.DASCharges"><code>TensorNetworkTensors.DASCharges</code></a></li><li><a href="#TensorNetworkTensors.DASSector"><code>TensorNetworkTensors.DASSector</code></a></li><li><a href="#TensorNetworkTensors.DTensor"><code>TensorNetworkTensors.DTensor</code></a></li><li><a href="#TensorNetworkTensors.InOut"><code>TensorNetworkTensors.InOut</code></a></li><li><a href="#TensorNetworkTensors.NDAS"><code>TensorNetworkTensors.NDAS</code></a></li><li><a href="#TensorNetworkTensors.NDASCharge"><code>TensorNetworkTensors.NDASCharge</code></a></li><li><a href="#TensorNetworkTensors.NDASCharges"><code>TensorNetworkTensors.NDASCharges</code></a></li><li><a href="#TensorNetworkTensors.U1"><code>TensorNetworkTensors.U1</code></a></li><li><a href="#TensorNetworkTensors.U1Charge"><code>TensorNetworkTensors.U1Charge</code></a></li><li><a href="#TensorNetworkTensors.U1Charges"><code>TensorNetworkTensors.U1Charges</code></a></li><li><a href="#TensorNetworkTensors.ZN"><code>TensorNetworkTensors.ZN</code></a></li><li><a href="#TensorNetworkTensors.ZNCharge"><code>TensorNetworkTensors.ZNCharge</code></a></li><li><a href="#TensorNetworkTensors.ZNCharges"><code>TensorNetworkTensors.ZNCharges</code></a></li><li><a href="#TensorNetworkTensors.:⊕-Tuple{DASCharges}"><code>TensorNetworkTensors.:⊕</code></a></li><li><a href="#TensorNetworkTensors.allsectors-Union{Tuple{Tuple{Vararg{DASCharges,N}}}, Tuple{N}} where N"><code>TensorNetworkTensors.allsectors</code></a></li><li><a href="#TensorNetworkTensors.charge-Tuple{DASTensor}"><code>TensorNetworkTensors.charge</code></a></li><li><a href="#TensorNetworkTensors.charge-Tuple{DASSector}"><code>TensorNetworkTensors.charge</code></a></li><li><a href="#TensorNetworkTensors.chargeindex"><code>TensorNetworkTensors.chargeindex</code></a></li><li><a href="#TensorNetworkTensors.charges-Tuple{DASTensor}"><code>TensorNetworkTensors.charges</code></a></li><li><a href="#TensorNetworkTensors.connectingcharge-Tuple{DASTensor{#s29,2,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM where #s29}"><code>TensorNetworkTensors.connectingcharge</code></a></li><li><a href="#TensorNetworkTensors.covariantsectors"><code>TensorNetworkTensors.covariantsectors</code></a></li><li><a href="#TensorNetworkTensors.fuselegs"><code>TensorNetworkTensors.fuselegs</code></a></li><li><a href="#TensorNetworkTensors.fuselegs-Union{Tuple{SYM}, Tuple{N}, Tuple{T}, Tuple{M}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES,Any,InOut{M}}} where SYM where N where T where M"><code>TensorNetworkTensors.fuselegs</code></a></li><li><a href="#TensorNetworkTensors.fuselegs!"><code>TensorNetworkTensors.fuselegs!</code></a></li><li><a href="#TensorNetworkTensors.gatherby-Tuple{Function,Any}"><code>TensorNetworkTensors.gatherby</code></a></li><li><a href="#TensorNetworkTensors.groupby-Tuple{Function,Any}"><code>TensorNetworkTensors.groupby</code></a></li><li><a href="#TensorNetworkTensors.in_out-Tuple{DASTensor}"><code>TensorNetworkTensors.in_out</code></a></li><li><a href="#TensorNetworkTensors.initwith!-Union{Tuple{N}, Tuple{T}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM,Any}} where N where T"><code>TensorNetworkTensors.initwith!</code></a></li><li><a href="#TensorNetworkTensors.initwithrand!-Tuple{DASTensor}"><code>TensorNetworkTensors.initwithrand!</code></a></li><li><a href="#TensorNetworkTensors.initwithzero!-Tuple{DASTensor}"><code>TensorNetworkTensors.initwithzero!</code></a></li><li><a href="#TensorNetworkTensors.invariantsectors-Tuple{Any,InOut}"><code>TensorNetworkTensors.invariantsectors</code></a></li><li><a href="#TensorNetworkTensors.isinvariant-Tuple{DASTensor}"><code>TensorNetworkTensors.isinvariant</code></a></li><li><a href="#TensorNetworkTensors.setcharges!-Tuple{DASTensor,Any}"><code>TensorNetworkTensors.setcharges!</code></a></li><li><a href="#TensorNetworkTensors.setin_out!-Tuple{DASTensor,Any}"><code>TensorNetworkTensors.setin_out!</code></a></li><li><a href="#TensorNetworkTensors.setsizes!-Tuple{DASTensor,Any}"><code>TensorNetworkTensors.setsizes!</code></a></li><li><a href="#TensorNetworkTensors.sizes-Tuple{DASTensor}"><code>TensorNetworkTensors.sizes</code></a></li><li><a href="#TensorNetworkTensors.splitlegs"><code>TensorNetworkTensors.splitlegs</code></a></li><li><a href="#TensorNetworkTensors.splitlegs!"><code>TensorNetworkTensors.splitlegs!</code></a></li><li><a href="#TensorNetworkTensors.svdtrunc_discardzero-Tuple{Any}"><code>TensorNetworkTensors.svdtrunc_discardzero</code></a></li><li><a href="#TensorNetworkTensors.svdtrunc_maxcumerror-Tuple{Real}"><code>TensorNetworkTensors.svdtrunc_maxcumerror</code></a></li><li><a href="#TensorNetworkTensors.svdtrunc_maxerror-Tuple{Real}"><code>TensorNetworkTensors.svdtrunc_maxerror</code></a></li><li><a href="#TensorNetworkTensors.svdtrunc_maxχ-Tuple{Any}"><code>TensorNetworkTensors.svdtrunc_maxχ</code></a></li><li><a href="#TensorNetworkTensors.symmetry-Union{Tuple{DASTensor{#s15,#s16,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where #s16 where #s15}, Tuple{SYM}} where SYM"><code>TensorNetworkTensors.symmetry</code></a></li><li><a href="#TensorNetworkTensors.tensor-Tuple{DASTensor}"><code>TensorNetworkTensors.tensor</code></a></li><li><a href="#TensorNetworkTensors.tensorqr-Tuple{AbstractTensor,Any}"><code>TensorNetworkTensors.tensorqr</code></a></li><li><a href="#TensorNetworkTensors.tensorqr"><code>TensorNetworkTensors.tensorqr</code></a></li><li><a href="#TensorNetworkTensors.tensorrq"><code>TensorNetworkTensors.tensorrq</code></a></li><li><a href="#TensorNetworkTensors.tensorrq"><code>TensorNetworkTensors.tensorrq</code></a></li><li><a href="#TensorNetworkTensors.tensorsvd-Tuple{AbstractTensor,Any}"><code>TensorNetworkTensors.tensorsvd</code></a></li><li><a href="#TensorNetworkTensors.tensorsvd"><code>TensorNetworkTensors.tensorsvd</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.AbstractTensor" href="#TensorNetworkTensors.AbstractTensor"><code>TensorNetworkTensors.AbstractTensor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractTensor{T,N}</code></pre><p>Abstract supertype for all tensornetwork-tensors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/TensorNetworkTensors.jl#LL14-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.DAS" href="#TensorNetworkTensors.DAS"><code>TensorNetworkTensors.DAS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DAS</code></pre><p>Abstract supertype of all Discrete Abelian Symmetries</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.DASCharge" href="#TensorNetworkTensors.DASCharge"><code>TensorNetworkTensors.DASCharge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DASCharge</code></pre><p>Abstract supertype of all Charges of Discrete Abelian Symmetries</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL13-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.DASCharges" href="#TensorNetworkTensors.DASCharges"><code>TensorNetworkTensors.DASCharges</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DASCharges</code></pre><p>Abstract supertype of all collections of Charges of Discrete Abelian Symmetries</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL7-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.DASSector" href="#TensorNetworkTensors.DASSector"><code>TensorNetworkTensors.DASSector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DASSector{N,T}</code></pre><p>DASSectors are a configuration of charges that are allowed under a given symmetry and index degeneracy spaces in DASTensors{T,N}.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; DASSector(U1Charge(1), U1Charge(2))
DASSector(U1Charge(1), U1Charge(2))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL62-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.DTensor" href="#TensorNetworkTensors.DTensor"><code>TensorNetworkTensors.DTensor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DTensor{T,N} &lt;: AbstractTensor{T,N}</code></pre><p>wrapper for generic Array{T,N} to represent dense tensors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DTensors.jl#LL1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.InOut" href="#TensorNetworkTensors.InOut"><code>TensorNetworkTensors.InOut</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InOut{N}</code></pre><p>InOut describes whether representations of the DAS act on an index of a DASTensor{T,N} directly or via their dual. InOut(1,1,1,-1) can be read as the first three indices corresponding to incoming, the last as an outgoing index w.r.t the group action.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL115-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.NDAS" href="#TensorNetworkTensors.NDAS"><code>TensorNetworkTensors.NDAS</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NDAS{N,S} &lt;: DAS</code></pre><p>wraps multiple independent symmetries to work together.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt;NDAS(U1(), Z2())
NDAS{2,(U1, Z2)}()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/NDAS.jl#LL1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.NDASCharge" href="#TensorNetworkTensors.NDASCharge"><code>TensorNetworkTensors.NDASCharge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NDASCharge{N} &lt;: DASCharge</code></pre><p>holds the charge of multiple independent symmetries grouped together.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = NDASCharge(U1Charge(1), Z2Charge(1));
julia&gt; a ⊕ a
NDASCharge(U1Charge(2), Z2Charge(0))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/NDAS.jl#LL53-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.NDASCharges" href="#TensorNetworkTensors.NDASCharges"><code>TensorNetworkTensors.NDASCharges</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NDASCharges{N,T} &lt;: DASCharges</code></pre><p>holds combinations of multiple independent <code>DASCharges</code> that are grouped together. Yields <code>NDASCharge{N,T}</code>s upon iteration.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = NDASCharges(U1Charges(-1:1), ZNCharges{3}());
julia&gt; foreach(println, a)
NDASCharge(U1Charge(-1), Z3Charge(0))
NDASCharge(U1Charge(0), Z3Charge(0))
NDASCharge(U1Charge(1), Z3Charge(0))
NDASCharge(U1Charge(-1), Z3Charge(1))
NDASCharge(U1Charge(0), Z3Charge(1))
NDASCharge(U1Charge(1), Z3Charge(1))
NDASCharge(U1Charge(-1), Z3Charge(2))
NDASCharge(U1Charge(0), Z3Charge(2))
NDASCharge(U1Charge(1), Z3Charge(2))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/NDAS.jl#LL14-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.U1" href="#TensorNetworkTensors.U1"><code>TensorNetworkTensors.U1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">U1 &lt;: DAS</code></pre><p>U1 symmetry singleton-type</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/U1.jl#LL1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.U1Charge" href="#TensorNetworkTensors.U1Charge"><code>TensorNetworkTensors.U1Charge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">U1Charge &lt;: DASCharge</code></pre><p>holds the charge of a U1 symmetry as an integer.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt;a = U1Charge(1);
julia&gt;a ⊕ a
U1Charge(2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/U1.jl#LL40-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.U1Charges" href="#TensorNetworkTensors.U1Charges"><code>TensorNetworkTensors.U1Charges</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">U1Charges &lt;: DASCharges</code></pre><p>type for collection of <code>U1Charge</code> that holds <code>StepRange{Int,Int}</code> which represents the valid values for <code>U1Charge</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt;a = U1Charges(-1:1);
julia&gt;foreach(println, a)
U1Charge(-1)
U1Charge(0)
U1Charge(1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/U1.jl#LL7-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.ZN" href="#TensorNetworkTensors.ZN"><code>TensorNetworkTensors.ZN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ZN{N} &lt;: DAS</code></pre><p>ZN symmetry singleton type where N is an Int.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/ZN.jl#LL1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.ZNCharge" href="#TensorNetworkTensors.ZNCharge"><code>TensorNetworkTensors.ZNCharge</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ZNCharge{N} &lt;: DASCharge</code></pre><p>holds the charge of a ZN symmetry as an integer. The integer is taken <code>mod N</code> s.t. the charge is always between <code>0</code> and <code>N-1</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt;a = ZNCharge{2}(1);
julia&gt;a ⊕ a
ZNCharge{2}(0)

julia&gt;a = ZNCharge{2}(3) == ZNCharge{2}(1)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/ZN.jl#LL35-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.ZNCharges" href="#TensorNetworkTensors.ZNCharges"><code>TensorNetworkTensors.ZNCharges</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ZNCharges{N} &lt;: DASCharges</code></pre><p>singleton-type for collections of <code>ZNCharge{N}</code> objects. Only the type parameter is provided - <code>ZNCharges{N}</code> doesn&#39;t have a field. Upon iteration yields <code>ZNCharge{N}(i)</code> for <code>i = 0,...,N-1</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt;a = ZNCharges{2}()
julia&gt;foreach(println, a)
ZNCharge{2}(0)
ZNCharge{2}(1)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/dastensor/ZN.jl#LL8-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.:⊕-Tuple{DASCharges}" href="#TensorNetworkTensors.:⊕-Tuple{DASCharges}"><code>TensorNetworkTensors.:⊕</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">⊕(a::T, bs::T...) where {T&lt;:Union{DASCharge, DASCharges}}</code></pre><p>returns the result of fusing one or more <code>DASCharge</code> or <code>DASCharges</code> together. Fusing <code>DASCharges</code> yields a <code>DASCharges</code> that holds all elements that result from fusing the <code>DASCharges</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL20-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.allsectors-Union{Tuple{Tuple{Vararg{DASCharges,N}}}, Tuple{N}} where N" href="#TensorNetworkTensors.allsectors-Union{Tuple{Tuple{Vararg{DASCharges,N}}}, Tuple{N}} where N"><code>TensorNetworkTensors.allsectors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allsectors(chs)</code></pre><p>returns a generator that generates all possible combinations of charges in <code>chs</code> wrapped in a <code>DASSector</code>.</p><p>#Example</p><pre><code class="language-julia-repl">julia&gt; allsectors((U1Charges(-1:1), U1Charges(4:5))) |&gt; collect
3×2 Array{DASSector{2,U1Charge},2}:
 DASSector(U1Charge(-1), U1Charge(4))  DASSector(U1Charge(-1), U1Charge(5))
 DASSector(U1Charge(0), U1Charge(4))   DASSector(U1Charge(0), U1Charge(5))
 DASSector(U1Charge(1), U1Charge(4))   DASSector(U1Charge(1), U1Charge(5))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL157-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.charge-Tuple{DASSector}" href="#TensorNetworkTensors.charge-Tuple{DASSector}"><code>TensorNetworkTensors.charge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">charge(a::DASSector)</code></pre><p>returns the charge which is calculated as minus the sum of all charges it contains.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL95-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.charge-Tuple{DASTensor}" href="#TensorNetworkTensors.charge-Tuple{DASTensor}"><code>TensorNetworkTensors.charge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">charge(a::DASTensor)</code></pre><p>returns the charge of a tensor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL286-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.chargeindex" href="#TensorNetworkTensors.chargeindex"><code>TensorNetworkTensors.chargeindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">chargeindex(ch::DASCharge, chs::DASCharges)</code></pre><p>returns the index i of ch in chs</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ch = U1Charge(0); chs = U1Charges(-1:1);
julia&gt; chargeindex(ch, chs)
2
julia&gt; chs[2] == ch
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.charges-Tuple{DASTensor}" href="#TensorNetworkTensors.charges-Tuple{DASTensor}"><code>TensorNetworkTensors.charges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">charges(A::DASTensor[,i])</code></pre><p>returns the charges of <code>A</code>. If <code>i</code> is specified as either <code>Int</code> or <code>Tuple</code>, returns only the charges of the indices in <code>i</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL214-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.covariantsectors" href="#TensorNetworkTensors.covariantsectors"><code>TensorNetworkTensors.covariantsectors</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">covariantsectors(chs, io[, ch = zero(chs)])</code></pre><p>returns  all sectors in allsectors(io ⊗ chs) that have total charge ch</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL173-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.fuselegs" href="#TensorNetworkTensors.fuselegs"><code>TensorNetworkTensors.fuselegs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fuselegs(A, indexes)</code></pre><p>Fuse the indices in <code>A</code> as given by <code>indexes</code> where <code>indexes</code> is a tuple containing indices either alone or grouped in tuples - the latter will be fused. Returns a tuple of a tensor and the object necessary to undo the fusion.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = DTensor(collect(reshape(1:8,2,2,2))
DTensor{Int64,3}[1 3; 2 4]
[5 7; 6 8]
julia&gt; fuselegs(a, ((1,2),3))
(DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/splitfuse.jl#LL3-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.fuselegs!" href="#TensorNetworkTensors.fuselegs!"><code>TensorNetworkTensors.fuselegs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fuselegs!(AF,A, indexes)</code></pre><p>In-place version of <code>fuselegs</code> where <code>AF</code> is a tensor of the correct type and size to hold the fused version of <code>A</code>. See <a href="#TensorNetworkTensors.fuselegs"><code>fuselegs</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/splitfuse.jl#LL21-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.fuselegs-Union{Tuple{SYM}, Tuple{N}, Tuple{T}, Tuple{M}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES,Any,InOut{M}}} where SYM where N where T where M" href="#TensorNetworkTensors.fuselegs-Union{Tuple{SYM}, Tuple{N}, Tuple{T}, Tuple{M}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES,Any,InOut{M}}} where SYM where N where T where M"><code>TensorNetworkTensors.fuselegs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fuselegs(A, indexes[, io])</code></pre><p>For <code>DASTensor</code>s, the directions of the resulting legs might be specified. If <code>io</code> is ommitted, the default is <code>InOut(1,1,1...)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/splitfuse.jl#LL198-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.gatherby-Tuple{Function,Any}" href="#TensorNetworkTensors.gatherby-Tuple{Function,Any}"><code>TensorNetworkTensors.gatherby</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gatherby(f, xs)</code></pre><p>Like <code>groupby</code> but only returns values, i.e. elements of <code>xs</code> in <code>Vector</code>s such that <code>f</code> applied to an element of a group is the same as for any other element of that <code>Vector</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; gatherby(isodd, 1:10)
2-element Array{Array{Int64,1},1}:
 [2, 4, 6, 8, 10]
 [3, 5, 7, 9]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/auxiliaryfunctions.jl#LL31-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.groupby-Tuple{Function,Any}" href="#TensorNetworkTensors.groupby-Tuple{Function,Any}"><code>TensorNetworkTensors.groupby</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">groupby(f, xs)</code></pre><p>group values <code>x ∈ xs</code> by the result of applying <code>f</code>. Returns a <code>Dict</code> with keys <code>yi</code> and values <code>[xi1, xi2,...]</code> such that <code>f(xij) = yi</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; groupby(isodd,1:10)
Dict{Bool,Array{Int64,1}} with 2 entries:
  false =&gt; [2, 4, 6, 8, 10]
  true  =&gt; [3, 5, 7, 9]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/auxiliaryfunctions.jl#LL1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.in_out-Tuple{DASTensor}" href="#TensorNetworkTensors.in_out-Tuple{DASTensor}"><code>TensorNetworkTensors.in_out</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">in_out(A::DASTensor[,i])</code></pre><p>returns the <code>InOut</code> of <code>A</code> which specifies the action of the symmetry group on the corresponding leg. If <code>i</code> is specified as either <code>Int</code> or <code>Tuple</code>, returns only the charges of the indices in <code>i</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL236-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.initwithrand!-Tuple{DASTensor}" href="#TensorNetworkTensors.initwithrand!-Tuple{DASTensor}"><code>TensorNetworkTensors.initwithrand!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initwithrand!(A::DASTensor)</code></pre><p>construct all valid sectors in <code>A</code> and initialize their degeneracy spaces with <code>rand</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL334-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.initwithzero!-Tuple{DASTensor}" href="#TensorNetworkTensors.initwithzero!-Tuple{DASTensor}"><code>TensorNetworkTensors.initwithzero!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initwithzero!(A::DASTensor)</code></pre><p>construct all valid sectors  in <code>A</code> and initialize their degeneracy spaces with zeros.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL327-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.invariantsectors-Tuple{Any,InOut}" href="#TensorNetworkTensors.invariantsectors-Tuple{Any,InOut}"><code>TensorNetworkTensors.invariantsectors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">covariantsectors(chs, io)</code></pre><p>returns all sectors in  allsectors(io ⊗ chs) that have total charge zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL180-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.isinvariant-Tuple{DASTensor}" href="#TensorNetworkTensors.isinvariant-Tuple{DASTensor}"><code>TensorNetworkTensors.isinvariant</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isinvariant(a::DASTensor)</code></pre><p>return true if <code>charge(a)</code> is <code>zero</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL293-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.setcharges!-Tuple{DASTensor,Any}" href="#TensorNetworkTensors.setcharges!-Tuple{DASTensor,Any}"><code>TensorNetworkTensors.setcharges!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setcharges!(A::DASTensor, chs)</code></pre><p>set the charges of <code>A</code> to be <code>chs</code> where the latter is a tuple of <code>DASCharges</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL269-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.setin_out!-Tuple{DASTensor,Any}" href="#TensorNetworkTensors.setin_out!-Tuple{DASTensor,Any}"><code>TensorNetworkTensors.setin_out!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setin_out!(A::DASTensor, io)</code></pre><p>set the <code>InOut</code> of <code>A</code> to be <code>io</code> where the latter is a <code>InOut</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL279-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.setsizes!-Tuple{DASTensor,Any}" href="#TensorNetworkTensors.setsizes!-Tuple{DASTensor,Any}"><code>TensorNetworkTensors.setsizes!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setsizes!(A::DASTensor, s)</code></pre><p>set the sizes of <code>A</code> to be <code>s</code> where the latter is a tuple of <code>Vector{Int}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL274-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.sizes-Tuple{DASTensor}" href="#TensorNetworkTensors.sizes-Tuple{DASTensor}"><code>TensorNetworkTensors.sizes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sizes(A::DASTensor[,i])</code></pre><p>returns the sizes of <code>A</code> as a tuple of vectors <code>v</code> such that the degeneracy space associated with a charge <code>ch</code> has size <code>v[chargeindex(ch, chs)]</code> where <code>chs</code> is the <code>DASCharges</code> associated with the specified leg. If <code>i</code> is specified as either <code>Int</code> or <code>Tuple</code>, returns only the charges of the indices in <code>i</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL224-L231">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.splitlegs" href="#TensorNetworkTensors.splitlegs"><code>TensorNetworkTensors.splitlegs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">splitlegs(A, indexes, rs...)</code></pre><p>Split the indices in <code>A</code> as given by <code>indexes</code> and <code>rs</code>. <code>indexes</code> is a tuple of integers and 3-tuple where each 3-tuple (i,j,k) specifies that index <code>i</code> in <code>A</code> is split according to <code>rs[j]</code>, index <code>k</code> therein. Returns tensor with fused legs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = DTensor(collect(reshape(1:8,2,2,2))
DTensor{Int64,3}[1 3; 2 4]
[5 7; 6 8]
julia&gt; af, rs = fuselegs(a, ((1,2),3))
(DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))
julia&gt; splitlegs(af, ((1,1,1),(1,1,2),2), rs...)
DTensor{Int64,3}[1 3; 2 4]
[5 7; 6 8]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/splitfuse.jl#LL30-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.splitlegs!" href="#TensorNetworkTensors.splitlegs!"><code>TensorNetworkTensors.splitlegs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">splitlegs!(AS,A, indexes, rs...)</code></pre><p>In-place version of <code>splitlegs</code> where <code>AS</code> is a tensor of the correct type and size to hold the split version of <code>A</code>. See <a href="#TensorNetworkTensors.splitlegs"><code>splitlegs</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/splitfuse.jl#LL52-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.svdtrunc_discardzero-Tuple{Any}" href="#TensorNetworkTensors.svdtrunc_discardzero-Tuple{Any}"><code>TensorNetworkTensors.svdtrunc_discardzero</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">svdtrunc_discardzero(s)</code></pre><p>return the number of non-zero values in s</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL50-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.svdtrunc_maxcumerror-Tuple{Real}" href="#TensorNetworkTensors.svdtrunc_maxcumerror-Tuple{Real}"><code>TensorNetworkTensors.svdtrunc_maxcumerror</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">svdtrunc_maxcumerror(ϵ::Real; χ::Int = typemax(Int))</code></pre><p>return a function that returns then min of χ and l where l is the number of singular values that need to be kept to have the truncated sum up to not more than ϵ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL63-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.svdtrunc_maxerror-Tuple{Real}" href="#TensorNetworkTensors.svdtrunc_maxerror-Tuple{Real}"><code>TensorNetworkTensors.svdtrunc_maxerror</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">svdtrunc_maxerror(ϵ::Real; χ::Int = typemax(Int))</code></pre><p>return a function that returns then min of χ and l where l is the number of singular values that need to be kept such that the largest discarded singular value is below ϵ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL71-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.svdtrunc_maxχ-Tuple{Any}" href="#TensorNetworkTensors.svdtrunc_maxχ-Tuple{Any}"><code>TensorNetworkTensors.svdtrunc_maxχ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">svdtrunc_maxχ(χ)</code></pre><p>return a function that given singular values <code>s</code> returns the min of the length of <code>s</code> and χ.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL56-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.symmetry-Union{Tuple{DASTensor{#s15,#s16,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where #s16 where #s15}, Tuple{SYM}} where SYM" href="#TensorNetworkTensors.symmetry-Union{Tuple{DASTensor{#s15,#s16,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where #s16 where #s15}, Tuple{SYM}} where SYM"><code>TensorNetworkTensors.symmetry</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">symmetry(A::DASTensor)</code></pre><p>returns the symmetry of a tensor <code>A</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL258-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.tensor-Tuple{DASTensor}" href="#TensorNetworkTensors.tensor-Tuple{DASTensor}"><code>TensorNetworkTensors.tensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tensor(A::DASTensor[,i])</code></pre><p>returns a dictionary of <code>DASSectors</code> and their associated degeneracy spaces.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL246-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.tensorqr" href="#TensorNetworkTensors.tensorqr"><code>TensorNetworkTensors.tensorqr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tensorqr(A::AbstractTensor)</code></pre><p>returns tensor Q,R such that A = QR and Q is an orthogonal/unitary matrix and R is an upper triangular matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL150-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.tensorqr-Tuple{AbstractTensor,Any}" href="#TensorNetworkTensors.tensorqr-Tuple{AbstractTensor,Any}"><code>TensorNetworkTensors.tensorqr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tensorqr(A::AbstractTensor, inds)</code></pre><p>returns the <code>tensorqr</code> of <code>A</code> fused according to <code>inds</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL158-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.tensorrq" href="#TensorNetworkTensors.tensorrq"><code>TensorNetworkTensors.tensorrq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tensorrq(A::AbstractTensor)</code></pre><p>returns tensor R,Q such that A = RQ and Q is obeys Q*Q&#39; = 1 and R is triangular. This is simply a wrapper for <code>tensorqr</code>, useful for e.g. MPS canonicalization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL201-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.tensorrq" href="#TensorNetworkTensors.tensorrq"><code>TensorNetworkTensors.tensorrq</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tensorrq(A::AbstractTensor, inds)</code></pre><p>returns the <code>tensorrq</code> of <code>A</code> fused according to <code>inds</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL210-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.tensorsvd" href="#TensorNetworkTensors.tensorsvd"><code>TensorNetworkTensors.tensorsvd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tensorsvd(A::AbstractTensor{T,2}; svdtrunc)</code></pre><p>returns the <code>svd</code> of an AbstractTensor. <code>svdtrunc</code> is a function that has the singular values as input and returns a number specifying how many of them to keep. The default <code>svdtrunc</code> is <code>svdtrunc_default</code> and keeps all of them.</p><p>Other options are: svdtrunc<em>discardzero svdtrunc</em>maxχ svdtrunc<em>maxcumerror svdtrunc</em>maxerror</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.tensorsvd-Tuple{AbstractTensor,Any}" href="#TensorNetworkTensors.tensorsvd-Tuple{AbstractTensor,Any}"><code>TensorNetworkTensors.tensorsvd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tensorsvd(A::AbstractTensor, indexes; svdtrunc)</code></pre><p>works like <code>tensorsvd</code> except that <code>A</code> can have arbitrary rank. <code>indexes</code> specifies which indices the fuse for <code>A</code> to be a rank-2 tensor as in <code>fuselegs</code>. The tensor is then fused, <code>tensorsvd</code> applied and split again.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL27-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.connectingcharge-Tuple{DASTensor{#s29,2,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM where #s29}" href="#TensorNetworkTensors.connectingcharge-Tuple{DASTensor{#s29,2,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM where #s29}"><code>TensorNetworkTensors.connectingcharge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">connectingcharge(A)</code></pre><p>where A is a rank-2 DASTensor, returns the charges on the second index that can be realized given the charges on the first index and the charge of A.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/tensorfactorization.jl#LL129-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TensorNetworkTensors.initwith!-Union{Tuple{N}, Tuple{T}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM,Any}} where N where T" href="#TensorNetworkTensors.initwith!-Union{Tuple{N}, Tuple{T}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM,Any}} where N where T"><code>TensorNetworkTensors.initwith!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">initwith!(A::DASTensor{T}, fun [,ch])</code></pre><p>modifies <code>A</code> such that each sector with charge <code>ch</code> (default=zero) is (independently) set to <code>fun(T, dims...)</code> where <code>dims</code> is the size of the degeneracy space for the sector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/TensorNetworkTensors.jl/blob/476124381e9d0a4295b6ef5596f7d50b45648d2a/src/DASTensors.jl#LL307-L311">source</a></section><footer><hr/></footer></article></body></html>
