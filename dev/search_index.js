var documenterSearchIndex = {"docs":
[{"location":"#TensorNetworkTensors.jl-1","page":"Home","title":"TensorNetworkTensors.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Tensors for Tensor Network Methods. TensorNetworkTensors.jl overloads methods from TensorOperations and KrylovKit to work with Tensors that might be symmetric under some abelina symmetry.","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Tensors-1","page":"Home","title":"Tensors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can define tensors without symmetry using the DTensor type as","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> a = DTensor{Complex{Float64}}((2,2));","category":"page"},{"location":"#","page":"Home","title":"Home","text":"which will return a 2x2-tensor with elements of type Complex{Float64}. DTensor is just a thin wrapper around Array.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A tensor with a symmetry can be defined by specifying the:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"symmetry\npossible charge\nsizes of the degeneracy spaces of those charge\naction of the group acts on an index","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The currently implemented Discrete Abelian Symmetries are U1 and ZN symmetries. To define a U1 symmetric rank-3 tensor which, in the particle conservation picture, has two incoming, one outgoing leg and supports carrying between 3 and -3 particles per leg where each charge has a degeneracy-size of 2, we write:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> sym = U1()\njulia> chs = (U1Charges(-3:3), U1Charges(-3:3), U1Charges(-3:3))\njulia> dims = ([2 for ch in U1Charges(-3:3)],\n                [2 for ch in U1Charges(-3:3)],\n                [2 for ch in U1Charges(-3:3)])\njulia> io = InOut(1,1,-1)\njulia> a = DASTensor{Float64,3}(sym, chs, dims, io)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where a is a Discrete Abelian Symmetric rank-3 tensor with degeneracy tensors of type Float64. It's first two indices can be read as incoming while the last is outgoing. All indices support charges in U1Charges(-3:3) which can be looked at using","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> foreach(println, U1Charges(-3:3))\nU1Charge(-3)\nU1Charge(-2)\nU1Charge(-1)\nU1Charge(0)\nU1Charge(1)\nU1Charge(2)\nU1Charge(3)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The same for a Z2-symmetric tensor looks like","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> sym = ZN{2}()\njulia> chs = (ZNCharges{2}(), ZNCharges{2}(), ZNCharges{2}())\njulia> dims = ([2 for ch in ZNCharges{2}()],\n               [2 for ch in ZNCharges{2}()],\n               [2 for ch in ZNCharges{2}()])\njulia> io = InOut(1,1,-1)\njulia> a = DASTensor{Float64,3}(sym, chs, dims, io)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Above we just defined tensors but they are either filled with garbage (DTensor) or empty (DASTensor). To initialize a tensor, use initwithzero! or initwithrand!, e.g.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> a = DTensor{Complex{Float64}}((2,2))\nDTensor{Complex{Float64},2}Complex{Float64}[6.93789e-310+6.93789e-310im 6.93789e-310+6.93786e-310im; 6.93789e-310+6.93786e-310im 6.93786e-310+6.93789e-310im]\njulia> initwithzero!(a)\nDTensor{Complex{Float64},2}Complex{Float64}[0.0+0.0im 0.0+0.0im; 0.0+0.0im 0.0+0.0im]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For tensors with symmetry - DASTensor - the same works but the underlying structure is different:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> sym = ZN{2}()\njulia> chs = (ZNCharges{2}(), ZNCharges{2}(), ZNCharges{2}())\njulia> dims = ([2 for ch in ZNCharges{2}()],\n               [2 for ch in ZNCharges{2}()],\n               [2 for ch in ZNCharges{2}()])\njulia> io = InOut(1,1,-1)\njulia> a = DASTensor{Float64,3}(sym, chs, dims, io);\njulia> initwithzero!(a)\njulia> tensor(a)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To look into a DASTensor, you can use tensor to see the underlying dictionary which maps DASSectors, discrete abelian symmetry sectors, to degeneracy tensors.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dict{DASSector{3,ZNCharge{2}},Array{Float64,3}} with 4 entries:\n  DASSector(Z2Charge(0), Z2Charge(0), Z2Charge(0)) => [0.0 0.0; 0.0 0.0]…\n  DASSector(Z2Charge(0), Z2Charge(1), Z2Charge(1)) => [0.0 0.0; 0.0 0.0]…\n  DASSector(Z2Charge(1), Z2Charge(0), Z2Charge(1)) => [0.0 0.0; 0.0 0.0]…\n  DASSector(Z2Charge(1), Z2Charge(1), Z2Charge(0)) => [0.0 0.0; 0.0 0.0]…","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can also directly access a degeneracy tensor like this:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> a[DASSector(Z2Charge(0), Z2Charge(0), Z2Charge(0))]\n2×2×2 Array{Float64,3}:\n[:, :, 1] =\n 0.0  0.0\n 0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0\n 0.0  0.0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Specific functions for DASTensors include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"charges, setcharges!\nsizes, setsizes!\nin_out, setin_out!\ntensor, settensor!\nisinvariant\ncharge","category":"page"},{"location":"#","page":"Home","title":"Home","text":"to learn more, use ? as in e.g.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia>?charge\nsearch: charge charges chargedim chargetype chargesize chargestype chargeindex ZNCharge Z2Charge U1Charge ZNCharges Z2Charges U1Charges DASCharge setcharges! DASCharges NDASCharge NDASCharges splitchargeit SplitChargeIt connectingcharge\n\n  charge(a::DASSector)\n\n  returns the charge which is calculated as the the sum of all charges it contains.\n\n  ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n  charge(a::DASTensor)\n\n  returns the charge which is calculated as the charge of its non-zero sectors which needs to be unique.","category":"page"},{"location":"#Reshaping-1","page":"Home","title":"Reshaping","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Reshaping can be done by either fusing or splitting legs. Since splitting with symmetries is highly nontrivial, it might only be done after a fusion which provides the necessary information of how to recombine indices and charges.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To fuse indices, we use the function fuselegs:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"help?>fuselegs\n  fuselegs(A, indexes)\n\n  Fuse the indices in A as given by indexes where indexes is a tuple containing indices either alone or grouped in tuples - the latter will be fused. Returns a tuple of a tensor and the object necessary to undo the fusion.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> a = DTensor(collect(reshape(1:8,2,2,2))\n  DTensor{Int64,3}[1 3; 2 4]\n  [5 7; 6 8]\n  julia> fuselegs(a, ((1,2),3))\n  (DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))\n\n    ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n  fuselegs(A, indexes[, io])\n\n  For DASTensors, the directions of the resulting legs might be specified. If io is ommitted, the default is InOut(1,1,1...).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Fusion might also include permutation. Note that fuselegs returns two objects:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A new tensor that corresponds to the input with the fusion applie\nAn object to undo that fusion.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The latter is achieved using splitlegs:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"help?> splitlegs\nsearch: splitlegs splitlegs!\n\n  splitlegs(A, indexes, rs...)\n\n  Split the indices in A as given by indexes and rs. indexes is a tuple of integers and 3-tuple where each 3-tuple (i,j,k) specifies that index i in A is split according to rs[j], index k therein. Returns tensor with fused legs.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> a = DTensor(collect(reshape(1:8,2,2,2))\n  DTensor{Int64,3}[1 3; 2 4]\n  [5 7; 6 8]\n  julia> af, rs = fuselegs(a, ((1,2),3))\n  (DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))\n  julia> splitlegs(af, ((1,1,1),(1,1,2),2), rs...)\n  DTensor{Int64,3}[1 3; 2 4]\n  [5 7; 6 8]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The same is true for the case of DASTensors, although fuselegs returns a more complicated object of the type Reshaper. If there is already a tensor of the correct shape and charges available, both fuselegs and splitlegs can be used as their in-place version fuselegs! and splitlegs! (see help).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that fusion is specified with permutation of the indices of a tensor and indices grouped in a tuple are fused, e.g. ((1,2),3) means the first two indices of a rank-3 tensor are grouped whereas (1,(4,3),2) means that the third and fourth index of a rank-4 tensor are grouped and switched with the second index.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For splitting, indices are a list of integers and 3-tuples (i,j,k) where the latter specifies that index i in given tensor is split according to index j in the reshapeing-information and part k of that split is to be at the position of that tuple.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Let's look at an example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> sym = U1()\njulia> chs = (U1Charges(-3:3), U1Charges(-3:3), U1Charges(-3:3))\njulia> dims = ([2 for ch in U1Charges(-3:3)],\n                [2 for ch in U1Charges(-3:3)],\n                [2 for ch in U1Charges(-3:3)])\njulia> io = InOut(1,1,1)\njulia> a = DASTensor{Float64,3}(sym, chs, dims, io)\njulia> initwithrand!(a)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First we fuse indices 1 and 3 into (3,1) putting them in the first place and specifying the directions of the legs as both outgoing:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> af, rs = fuselegs(a, ((3,1),2),InOut(-1,-1))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To undo that fusion, we need to split the first index of af according to the first reshaper in rs (there's a reshaper for each index in the fused tensor in order). A valid splitting would be:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> splitlegs(af,((1,1,1),(1,1,2),2),rs...)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"but that would correspond to a permutation (3,1,2) of a. Additionally, the unfused index was also changed by switching its InOut! We thus want to specify both the correct permutation and that index 2 needs to be changed accordingly, arriving at","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> splitlegs(af, ((1,1,2),(2,2,1),(1,1,1)), rs...) ≈ a\ntrue","category":"page"},{"location":"#Factorizations-1","page":"Home","title":"Factorizations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"So far the factorizations available are tensorsvd which returns the SVD of a tensor, see","category":"page"},{"location":"#","page":"Home","title":"Home","text":"help?> tensorsvd\nsearch: tensorsvd tensorsvd! _tensorsvd TensorOperations\n\n  tensorsvd(A::AbstractTensor, indexes; svdtrunc)\n\n  works like tensorsvd except that A can have arbitrary rank.\n  indexes specifies which indices the fuse for A to be a rank-2 tensor as in fuselegs.\n  The tensor is then fused, tensorsvd applied and split again.\n\n  ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n  tensorsvd(A::AbstractTensor{T,2}; svdtrunc)\n\n  returns the svd of an AbstractTensor.\n  svdtrunc is a function that has the singular values as input and returns a number specifying how many of them to keep.\n  The default svdtrunc is svdtrunc_default and keeps all of them.\n\n  Other options are: svdtruncdiscardzero svdtruncmaxχ svdtruncmaxcumerror svdtruncmaxerror","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and tensorqr which returns the QR-decomposition of a tensor, see","category":"page"},{"location":"#","page":"Home","title":"Home","text":"help?> tensorqr\nsearch: tensorqr tensor tensorsvd tensoradd tensorsvd! tensortrace tensorcopy tensoradd! tensortrace! tensorcopy! tensorproduct tensorproduct! tensorcontract\n\n  tensorqr(A::AbstractTensor)\n\n  returns tensor Q,R such that A = QR and Q is an orthogonal/unitary matrix and R is an upper triangular matrix.\n\n  ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n  tensorqr(A::AbstractTensor, inds)\n\n  returns the tensorqr of A fused according to inds.","category":"page"},{"location":"#KrylovKit-1","page":"Home","title":"KrylovKit","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"All AbstractTensors work with KrylovKit, a package that combines a number of Krylov-based algorithms including exponentiate.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To use KrylovKit, follow the instruction for installation at the github repository and do","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using KrylovKit","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As an example, consider eigsolve for a tensor with two independent symmetries:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> a = DASTensor{Complex{Float64},2}(\n  NDAS(Z2(),U1()),\n  (NDASCharges(Z2Charges(), U1Charges(-1:1)), NDASCharges(Z2Charges(), U1Charges(-1:1))),\n  (fill(2,6), fill(2,6)),\n  InOut(1,-1))\njulia> initwithrand!(a)\njulia> using TensorOperations\njulia> @tensor a[1,2] := a[1,2] + a'[2,1];","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Since we are not working with a regular array, we need to provide an initial guess for an eigenvector, e.g.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> v0 = DASTensor{Complex{Float64},1}(\n         NDAS(Z2(),U1()),\n         (NDASCharges(Z2Charges(), U1Charges(-1:1)),),\n         (fill(2,6),),\n         InOut(1))\njulia> initwithrand!(v0)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then we can define a function for applying a to vectors like v0:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> f(v) = @tensor v2[1] :=  a[1,-1] * v[-1]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then we can use eigsolve with f and v0 to get an eigenvector of a or the map that it describes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> eigsolve(f,v0)\n[...]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"which returns two eigenvalues, two eigenvectors and an object containing information about convergence.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Similarly we can apply exp(0.1*a) to v0 with exponentiate:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> exponentiate(f,0.1,v0, ishermitian=true)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [TensorNetworkTensors]","category":"page"},{"location":"#TensorNetworkTensors.AbstractTensor","page":"Home","title":"TensorNetworkTensors.AbstractTensor","text":"AbstractTensor{T,N}\n\nAbstract supertype for all tensornetwork-tensors.\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.DAS","page":"Home","title":"TensorNetworkTensors.DAS","text":"DAS\n\nAbstract supertype of all Discrete Abelian Symmetries\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.DASCharge","page":"Home","title":"TensorNetworkTensors.DASCharge","text":"DASCharge\n\nAbstract supertype of all Charges of Discrete Abelian Symmetries\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.DASCharges","page":"Home","title":"TensorNetworkTensors.DASCharges","text":"DASCharges\n\nAbstract supertype of all collections of Charges of Discrete Abelian Symmetries\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.DASSector","page":"Home","title":"TensorNetworkTensors.DASSector","text":"DASSector{N,T}\n\nDASSectors are a configuration of charges that are allowed under a given symmetry and index degeneracy spaces in DASTensors{T,N}.\n\nExample\n\njulia> DASSector(U1Charge(1), U1Charge(2))\nDASSector(U1Charge(1), U1Charge(2))\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.DTensor","page":"Home","title":"TensorNetworkTensors.DTensor","text":"DTensor{T,N} <: AbstractTensor{T,N}\n\nwrapper for generic Array{T,N} to represent dense tensors.\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.InOut","page":"Home","title":"TensorNetworkTensors.InOut","text":"InOut{N}\n\nInOut describes whether representations of the DAS act on an index of a DASTensor{T,N} directly or via their dual. InOut(1,1,1,-1) can be read as the first three indices corresponding to incoming, the last as an outgoing index w.r.t the group action.\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.NDAS","page":"Home","title":"TensorNetworkTensors.NDAS","text":"NDAS{N,S} <: DAS\n\nwraps multiple independent symmetries to work together.\n\nExample\n\njulia>NDAS(U1(), Z2())\nNDAS{2,(U1, Z2)}()\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.NDASCharge","page":"Home","title":"TensorNetworkTensors.NDASCharge","text":"NDASCharge{N} <: DASCharge\n\nholds the charge of multiple independent symmetries grouped together.\n\nExample\n\njulia> a = NDASCharge(U1Charge(1), Z2Charge(1));\njulia> a ⊕ a\nNDASCharge(U1Charge(2), Z2Charge(0))\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.NDASCharges","page":"Home","title":"TensorNetworkTensors.NDASCharges","text":"NDASCharges{N,T} <: DASCharges\n\nholds combinations of multiple independent DASCharges that are grouped together. Yields NDASCharge{N,T}s upon iteration.\n\nExample\n\njulia> a = NDASCharges(U1Charges(-1:1), ZNCharges{3}());\njulia> foreach(println, a)\nNDASCharge(U1Charge(-1), Z3Charge(0))\nNDASCharge(U1Charge(0), Z3Charge(0))\nNDASCharge(U1Charge(1), Z3Charge(0))\nNDASCharge(U1Charge(-1), Z3Charge(1))\nNDASCharge(U1Charge(0), Z3Charge(1))\nNDASCharge(U1Charge(1), Z3Charge(1))\nNDASCharge(U1Charge(-1), Z3Charge(2))\nNDASCharge(U1Charge(0), Z3Charge(2))\nNDASCharge(U1Charge(1), Z3Charge(2))\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.U1","page":"Home","title":"TensorNetworkTensors.U1","text":"U1 <: DAS\n\nU1 symmetry singleton-type\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.U1Charge","page":"Home","title":"TensorNetworkTensors.U1Charge","text":"U1Charge <: DASCharge\n\nholds the charge of a U1 symmetry as an integer.\n\nExample\n\njulia>a = U1Charge(1);\njulia>a ⊕ a\nU1Charge(2)\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.U1Charges","page":"Home","title":"TensorNetworkTensors.U1Charges","text":"U1Charges <: DASCharges\n\ntype for collection of U1Charge that holds StepRange{Int,Int} which represents the valid values for U1Charge.\n\nExample\n\njulia>a = U1Charges(-1:1);\njulia>foreach(println, a)\nU1Charge(-1)\nU1Charge(0)\nU1Charge(1)\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.ZN","page":"Home","title":"TensorNetworkTensors.ZN","text":"ZN{N} <: DAS\n\nZN symmetry singleton type where N is an Int.\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.ZNCharge","page":"Home","title":"TensorNetworkTensors.ZNCharge","text":"ZNCharge{N} <: DASCharge\n\nholds the charge of a ZN symmetry as an integer. The integer is taken mod N s.t. the charge is always between 0 and N-1\n\nExample\n\njulia>a = ZNCharge{2}(1);\njulia>a ⊕ a\nZNCharge{2}(0)\n\njulia>a = ZNCharge{2}(3) == ZNCharge{2}(1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.ZNCharges","page":"Home","title":"TensorNetworkTensors.ZNCharges","text":"ZNCharges{N} <: DASCharges\n\nsingleton-type for collections of ZNCharge{N} objects. Only the type parameter is provided - ZNCharges{N} doesn't have a field. Upon iteration yields ZNCharge{N}(i) for i = 0,...,N-1\n\nExample\n\njulia>a = ZNCharges{2}()\njulia>foreach(println, a)\nZNCharge{2}(0)\nZNCharge{2}(1)\n\n\n\n\n\n","category":"type"},{"location":"#TensorNetworkTensors.:⊕-Tuple{DASCharges}","page":"Home","title":"TensorNetworkTensors.:⊕","text":"⊕(a::T, bs::T...) where {T<:Union{DASCharge, DASCharges}}\n\nreturns the result of fusing one or more DASCharge or DASCharges together. Fusing DASCharges yields a DASCharges that holds all elements that result from fusing the DASCharges.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.allsectors-Union{Tuple{Tuple{Vararg{DASCharges,N}}}, Tuple{N}} where N","page":"Home","title":"TensorNetworkTensors.allsectors","text":"allsectors(chs)\n\nreturns a generator that generates all possible combinations of charges in chs wrapped in a DASSector.\n\n#Example\n\njulia> allsectors((U1Charges(-1:1), U1Charges(4:5))) |> collect\n3×2 Array{DASSector{2,U1Charge},2}:\n DASSector(U1Charge(-1), U1Charge(4))  DASSector(U1Charge(-1), U1Charge(5))\n DASSector(U1Charge(0), U1Charge(4))   DASSector(U1Charge(0), U1Charge(5))\n DASSector(U1Charge(1), U1Charge(4))   DASSector(U1Charge(1), U1Charge(5))\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.charge-Tuple{DASSector}","page":"Home","title":"TensorNetworkTensors.charge","text":"charge(a::DASSector)\n\nreturns the charge which is calculated as minus the sum of all charges it contains.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.charge-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.charge","text":"charge(a::DASTensor)\n\nreturns the charge of a tensor.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.chargeindex","page":"Home","title":"TensorNetworkTensors.chargeindex","text":"chargeindex(ch::DASCharge, chs::DASCharges)\n\nreturns the index i of ch in chs\n\nExample\n\njulia> ch = U1Charge(0); chs = U1Charges(-1:1);\njulia> chargeindex(ch, chs)\n2\njulia> chs[2] == ch\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.charges-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.charges","text":"charges(A::DASTensor[,i])\n\nreturns the charges of A. If i is specified as either Int or Tuple, returns only the charges of the indices in i.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.covariantsectors","page":"Home","title":"TensorNetworkTensors.covariantsectors","text":"covariantsectors(chs, io[, ch = zero(chs)])\n\nreturns  all sectors in allsectors(io ⊗ chs) that have total charge ch\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.fuselegs","page":"Home","title":"TensorNetworkTensors.fuselegs","text":"fuselegs(A, indexes)\n\nFuse the indices in A as given by indexes where indexes is a tuple containing indices either alone or grouped in tuples - the latter will be fused. Returns a tuple of a tensor and the object necessary to undo the fusion.\n\nExamples\n\njulia> a = DTensor(collect(reshape(1:8,2,2,2))\nDTensor{Int64,3}[1 3; 2 4]\n[5 7; 6 8]\njulia> fuselegs(a, ((1,2),3))\n(DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.fuselegs!","page":"Home","title":"TensorNetworkTensors.fuselegs!","text":"fuselegs!(AF,A, indexes)\n\nIn-place version of fuselegs where AF is a tensor of the correct type and size to hold the fused version of A. See fuselegs\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.fuselegs-Union{Tuple{SYM}, Tuple{N}, Tuple{T}, Tuple{M}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES,Any,InOut{M}}} where SYM where N where T where M","page":"Home","title":"TensorNetworkTensors.fuselegs","text":"fuselegs(A, indexes[, io])\n\nFor DASTensors, the directions of the resulting legs might be specified. If io is ommitted, the default is InOut(1,1,1...).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.gatherby-Tuple{Function,Any}","page":"Home","title":"TensorNetworkTensors.gatherby","text":"gatherby(f, xs)\n\nLike groupby but only returns values, i.e. elements of xs in Vectors such that f applied to an element of a group is the same as for any other element of that Vector.\n\nExample\n\njulia> gatherby(isodd, 1:10)\n2-element Array{Array{Int64,1},1}:\n [2, 4, 6, 8, 10]\n [3, 5, 7, 9]\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.groupby-Tuple{Function,Any}","page":"Home","title":"TensorNetworkTensors.groupby","text":"groupby(f, xs)\n\ngroup values x ∈ xs by the result of applying f. Returns a Dict with keys yi and values [xi1, xi2,...] such that f(xij) = yi.\n\nExample\n\njulia> groupby(isodd,1:10)\nDict{Bool,Array{Int64,1}} with 2 entries:\n  false => [2, 4, 6, 8, 10]\n  true  => [3, 5, 7, 9]\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.in_out-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.in_out","text":"in_out(A::DASTensor[,i])\n\nreturns the InOut of A which specifies the action of the symmetry group on the corresponding leg. If i is specified as either Int or Tuple, returns only the charges of the indices in i.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.initwithrand!-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.initwithrand!","text":"initwithrand!(A::DASTensor)\n\nconstruct all valid sectors in A and initialize their degeneracy spaces with rand.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.initwithzero!-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.initwithzero!","text":"initwithzero!(A::DASTensor)\n\nconstruct all valid sectors  in A and initialize their degeneracy spaces with zeros.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.invariantsectors-Tuple{Any,InOut}","page":"Home","title":"TensorNetworkTensors.invariantsectors","text":"covariantsectors(chs, io)\n\nreturns all sectors in  allsectors(io ⊗ chs) that have total charge zero.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.isinvariant-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.isinvariant","text":"isinvariant(a::DASTensor)\n\nreturn true if charge(a) is zero.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.setcharges!-Tuple{DASTensor,Any}","page":"Home","title":"TensorNetworkTensors.setcharges!","text":"setcharges!(A::DASTensor, chs)\n\nset the charges of A to be chs where the latter is a tuple of DASCharges.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.setin_out!-Tuple{DASTensor,Any}","page":"Home","title":"TensorNetworkTensors.setin_out!","text":"setin_out!(A::DASTensor, io)\n\nset the InOut of A to be io where the latter is a InOut.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.setsizes!-Tuple{DASTensor,Any}","page":"Home","title":"TensorNetworkTensors.setsizes!","text":"setsizes!(A::DASTensor, s)\n\nset the sizes of A to be s where the latter is a tuple of Vector{Int}.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.sizes-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.sizes","text":"sizes(A::DASTensor[,i])\n\nreturns the sizes of A as a tuple of vectors v such that the degeneracy space associated with a charge ch has size v[chargeindex(ch, chs)] where chs is the DASCharges associated with the specified leg. If i is specified as either Int or Tuple, returns only the charges of the indices in i.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.splitlegs","page":"Home","title":"TensorNetworkTensors.splitlegs","text":"splitlegs(A, indexes, rs...)\n\nSplit the indices in A as given by indexes and rs. indexes is a tuple of integers and 3-tuple where each 3-tuple (i,j,k) specifies that index i in A is split according to rs[j], index k therein. Returns tensor with fused legs.\n\nExamples\n\njulia> a = DTensor(collect(reshape(1:8,2,2,2))\nDTensor{Int64,3}[1 3; 2 4]\n[5 7; 6 8]\njulia> af, rs = fuselegs(a, ((1,2),3))\n(DTensor{Int64,2}[1 5; 2 6; 3 7; 4 8], ((2, 2),))\njulia> splitlegs(af, ((1,1,1),(1,1,2),2), rs...)\nDTensor{Int64,3}[1 3; 2 4]\n[5 7; 6 8]\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.splitlegs!","page":"Home","title":"TensorNetworkTensors.splitlegs!","text":"splitlegs!(AS,A, indexes, rs...)\n\nIn-place version of splitlegs where AS is a tensor of the correct type and size to hold the split version of A. See splitlegs\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.svdtrunc_discardzero-Tuple{Any}","page":"Home","title":"TensorNetworkTensors.svdtrunc_discardzero","text":"svdtrunc_discardzero(s)\n\nreturn the number of non-zero values in s\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.svdtrunc_maxcumerror-Tuple{Real}","page":"Home","title":"TensorNetworkTensors.svdtrunc_maxcumerror","text":"svdtrunc_maxcumerror(ϵ::Real; χ::Int = typemax(Int))\n\nreturn a function that returns then min of χ and l where l is the number of singular values that need to be kept to have the truncated sum up to not more than ϵ.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.svdtrunc_maxerror-Tuple{Real}","page":"Home","title":"TensorNetworkTensors.svdtrunc_maxerror","text":"svdtrunc_maxerror(ϵ::Real; χ::Int = typemax(Int))\n\nreturn a function that returns then min of χ and l where l is the number of singular values that need to be kept such that the largest discarded singular value is below ϵ.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.svdtrunc_maxχ-Tuple{Any}","page":"Home","title":"TensorNetworkTensors.svdtrunc_maxχ","text":"svdtrunc_maxχ(χ)\n\nreturn a function that given singular values s returns the min of the length of s and χ.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.symmetry-Union{Tuple{DASTensor{#s15,#s16,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where #s16 where #s15}, Tuple{SYM}} where SYM","page":"Home","title":"TensorNetworkTensors.symmetry","text":"symmetry(A::DASTensor)\n\nreturns the symmetry of a tensor A\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.tensor-Tuple{DASTensor}","page":"Home","title":"TensorNetworkTensors.tensor","text":"tensor(A::DASTensor[,i])\n\nreturns a dictionary of DASSectors and their associated degeneracy spaces.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.tensorqr","page":"Home","title":"TensorNetworkTensors.tensorqr","text":"tensorqr(A::AbstractTensor)\n\nreturns tensor Q,R such that A = QR and Q is an orthogonal/unitary matrix and R is an upper triangular matrix.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.tensorqr-Tuple{AbstractTensor,Any}","page":"Home","title":"TensorNetworkTensors.tensorqr","text":"tensorqr(A::AbstractTensor, inds)\n\nreturns the tensorqr of A fused according to inds.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.tensorrq","page":"Home","title":"TensorNetworkTensors.tensorrq","text":"tensorrq(A::AbstractTensor)\n\nreturns tensor R,Q such that A = RQ and Q is obeys Q*Q' = 1 and R is triangular. This is simply a wrapper for tensorqr, useful for e.g. MPS canonicalization.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.tensorrq","page":"Home","title":"TensorNetworkTensors.tensorrq","text":"tensorrq(A::AbstractTensor, inds)\n\nreturns the tensorrq of A fused according to inds.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.tensorsvd","page":"Home","title":"TensorNetworkTensors.tensorsvd","text":"tensorsvd(A::AbstractTensor{T,2}; svdtrunc)\n\nreturns the svd of an AbstractTensor. svdtrunc is a function that has the singular values as input and returns a number specifying how many of them to keep. The default svdtrunc is svdtrunc_default and keeps all of them.\n\nOther options are: svdtruncdiscardzero svdtruncmaxχ svdtruncmaxcumerror svdtruncmaxerror\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkTensors.tensorsvd-Tuple{AbstractTensor,Any}","page":"Home","title":"TensorNetworkTensors.tensorsvd","text":"tensorsvd(A::AbstractTensor, indexes; svdtrunc)\n\nworks like tensorsvd except that A can have arbitrary rank. indexes specifies which indices the fuse for A to be a rank-2 tensor as in fuselegs. The tensor is then fused, tensorsvd applied and split again.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.connectingcharge-Tuple{DASTensor{#s29,2,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM where #s29}","page":"Home","title":"TensorNetworkTensors.connectingcharge","text":"connectingcharge(A)\n\nwhere A is a rank-2 DASTensor, returns the charges on the second index that can be realized given the charges on the first index and the charge of A.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkTensors.initwith!-Union{Tuple{N}, Tuple{T}, Tuple{DASTensor{T,N,SYM,CHARGES,SIZES,CHARGE} where CHARGE where SIZES where CHARGES where SYM,Any}} where N where T","page":"Home","title":"TensorNetworkTensors.initwith!","text":"initwith!(A::DASTensor{T}, fun [,ch])\n\nmodifies A such that each sector with charge ch (default=zero) is (independently) set to fun(T, dims...) where dims is the size of the degeneracy space for the sector.\n\n\n\n\n\n","category":"method"}]
}
